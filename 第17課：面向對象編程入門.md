## 第17課：面向對象編程入門

面向對象編程是一種非常流行的**編程範式**（programming paradigm），所謂編程範式就是**程序設計的方法論**，簡單的說就是程序員對程序的認知和理解以及他們編寫代碼的方式。

在前面的課程中，我們說過“**程序是指令的集合**”，運行程序時，程序中的語句會變成一條或多條指令，然後由CPU（中央處理器）去執行。為了簡化程序的設計，我們又講到了函數，**把相對獨立且經常重複使用的代碼放置到函數中**，在需要使用這些代碼的時候調用函數即可。如果一個函數的功能過於復雜和臃腫，我們又可以進一步**將函數進一步拆分為多個子函數**來降低系統的複雜性。

不知大家是否發現，我們的編程工作其實是寫程序的人按照計算機的工作方式通過代碼控制機器完成任務。但是，計算機的工作方式與人類正常的思維模式是不同的，如果編程就必須拋棄人類正常的思維方式去迎合計算機，編程的樂趣就少了很多，而“每個人都應該學習編程”的豪言壯語也就只能喊喊口號而已。這裡，我想說的並不是我們不能按照計算機的工作方式去編寫代碼，但是當我們需要開發一個複雜的系統時，這種方式會讓代碼過於復雜，從而導致開發和維護工作都變得舉步維艱。

隨著軟件複雜性的增加，編寫正確可靠的代碼會變成了一項極為艱鉅的任務，這也是很多人都堅信“軟件開發是人類改造世界所有活動中最為複雜的活動”的原因。如何用程序描述複雜系統和解決複雜問題，就成為了所有程序員必須要思考和直面的問題。誕生於上世紀70年代的Smalltalk語言讓軟件開發者看到了希望，因為它引入了一種新的編程範式叫面向對象編程。在面向對象編程的世界裡，程序中的**數據和操作數據的函數是一個邏輯上的整體**，我們稱之為**對象**，**對象可以接收消息**，解決問題的方法就是**創建對象並向對象發出各種各樣的消息**；通過消息傳遞，程序中的多個對象可以協同工作，這樣就能構造出複雜的系統並解決現實中的問題。當然，面向對象編程的雛形還可以向前追溯到更早期的Simula語言，但這不是我們現在要討論的重點。

> **說明：** 今天我們使用的很多高級程序設計語言都支持面向對象編程，但是面向對象編程也不是解決軟件開發中所有問題的“銀彈”，或者說在軟件開發這個行業目前還找不到這種所謂的“銀彈”。關於這個問題，大家可以參考IBM360系統之父弗雷德里克·布魯克斯所發表的論文《沒有銀彈：軟件工程的本質性與附屬性工作》或軟件工程的經典著作《人月神話》一書。

### 類和對象

如果要用一句話來概括面向對象編程，我認為下面的說法是相當精闢和準確的。

> **面向對象編程**：把一組數據和處理數據的方法組成**對象**，把行為相同的對象歸納為**類**，通過**封裝**隱藏對象的內部細節，通過**繼承**實現類的特化和泛化，通過**多態**實現基於對像類型的動態分派。

這句話對初學者來說可能不那麼容易理解，但是我可以先為大家圈出幾個關鍵詞：**對象**（object）、**類**（class）、**封裝**（encapsulation）、**繼承**（inheritance）、**多態**（polymorphism）。

我們先說說類和對像這兩個詞。在面向對象編程中，**類是一個抽象的概念，對像是一個具體的概念**。我們把同一類對象的共同特徵抽取出來就是一個類，比如我們經常說的人類，這是一個抽象概念，而我們每個人就是人類的這個抽象概念下的實實在在的存在，也就是一個對象。簡而言之，**類是對象的藍圖和模板，對像是類的實例，是可以接受消息的實體**。

在面向對象編程的世界中，**一切皆為對象**，**對像都有屬性和行為**，**每個對像都是獨一無二的**，而且**對像一定屬於某個類**。對象的屬性是對象的靜態特徵，對象的行為是對象的動態特徵。按照上面的說法，如果我們把擁有共同特徵的對象的屬性和行為都抽取出來，就可以定義出一個類。

<img src="https://gitee.com/jackfrued/mypic/raw/master/20210731182741.png" width="75%">

### 定義類

在Python中，可以使用`class`關鍵字加上類名來定義類，通過縮進我們可以確定類的代碼塊，就如同定義函數那樣。在類的代碼塊中，我們需要寫一些函數，我們說過類是一個抽象概念，那麼這些函數就是我們對一類對象共同的動態特徵的提取。寫在類裡面的函數我們通常稱之為**方法**，方法就是對象的行為，也就是對象可以接收的消息。方法的第一個參數通常都是`self`，它代表了接收這個消息的對象本身。

```Python
class Student:

    def study(self, course_name):
        print(f'學生正在學習{course_name}.')

    def play(self):
        print(f'學生正在玩遊戲.')
```

### 創建和使用對象

在我們定義好一個類之後，可以使用構造器語法來創建對象，代碼如下所示。

```Python
stu1 = Student()
stu2 = Student()
print(stu1)    # <__main__.Student object at 0x10ad5ac50>
print(stu2)    # <__main__.Student object at 0x10ad5acd0> 
print(hex(id(stu1)), hex(id(stu2)))    # 0x10ad5ac50 0x10ad5acd0
```

在類的名字後跟上圓括號就是所謂的構造器語法，上面的代碼創建了兩個學生對象，一個賦值給變量`stu1`，一個複制給變量`stu2`。當我們用`print`函數打印`stu1`和`stu2`兩個變量時，我們會看到輸出了對像在內存中的地址（十六進制形式），跟我們用`id`函數查看對象標識獲得的值是相同的。現在我們可以告訴大家，我們定義的變量其實保存的是一個對像在內存中的邏輯地址（位置），通過這個邏輯地址，我們就可以在內存中找到這個對象。所以`stu3 = stu2`這樣的賦值語句並沒有創建新的對象，只是用一個新的變量保存了已有對象的地址。

接下來，我們嘗試給對象發消息，即調用對象的方法。剛才的`Student`類中我們定義了`study`和`play`兩個方法，兩個方法的第一個參數`self`代表了接收消息的學生對象，`study`方法的第二個參數是學習的課程名稱。 Python中，給對象發消息有兩種方式，請看下面的代碼。

```Python
# 通過“類.方法”調用方法，第一個參數是接收消息的對象，第二個參數是學習的課程名稱
Student.study(stu1, 'Python程序設計')    # 學生正在學習Python程序設計.
# 通過“對象.方法”調用方法，點前面的對象就是接收消息的對象，只需要傳入第二個參數
stu1.study('Python程序設計')             # 學生正在學習Python程序設計.

Student.play(stu2)    # 學生正在玩遊戲.
stu2.play()           # 學生正在玩遊戲. 
```

### 初始化方法

大家可能已經註意到了，剛才我們創建的學生對像只有行為沒有屬性，如果要給學生對象定義屬性，我們可以修改`Student`類，為其添加一個名為`__init__`的方法。在我們調用`Student`類的構造器創建對象時，首先會在內存中獲得保存學生對象所需的內存空間，然後通過自動執行`__init__`方法，完成對內存的初始化操作，也就是把數據放到內存空間中。所以我們可以通過給`Student`類添加`__init__`方法的方式為學生對象指定屬性，同時完成對屬性賦初始值的操作，正因如此，`__init__`方法通常也被稱為初始化方法。

我們對上面的`Student`類稍作修改，給學生對象添加`name`（姓名）和`age`（年齡）兩個屬性。

```Python
class Student:
    """學生"""

    def __init__(self, name, age):
        """初始化方法"""
        self.name = name
        self.age = age

    def study(self, course_name):
        """學習"""
        print(f'{self.name}正在學習{course_name}.')

    def play(self):
        """玩耍"""
        print(f'{self.name}正在玩遊戲.')
```

修改剛才創建對象和給對象發消息的代碼，重新執行一次，看看程序的執行結果有什麼變化。

```Python
# 由於初始化方法除了self之外還有兩個參數
# 所以調用Student類的構造器創建對象時要傳入這兩個參數
stu1 = Student('駱昊', 40)
stu2 = Student('王大錘', 15)
stu1.study('Python程序設計')    # 駱昊正在學習Python程序設計.
stu2.play()                    # 王大錘正在玩遊戲.
```

### 打印對象

上面我們通過`__init__`方法在創建對象時為對象綁定了屬性並賦予了初始值。在Python中，以兩個下劃線`__`（讀作“dunder”）開頭和結尾的方法通常都是有特殊用途和意義的方法，我們一般稱之為**魔術方法**或**魔法方法**。如果我們在打印對象的時候不希望看到對象的地址而是看到我們自定義的信息，可以通過在類中放置`__repr__`魔術方法來做到，該方法返回的字符串就是用`print`函數打印對象的時候會顯示的內容，代碼如下所示。

```Python
class Student:
    """學生"""

    def __init__(self, name, age):
        """初始化方法"""
        self.name = name
        self.age = age

    def study(self, course_name):
        """學習"""
        print(f'{self.name}正在學習{course_name}.')

    def play(self):
        """玩耍"""
        print(f'{self.name}正在玩遊戲.')
    
    def __repr__(self):
        return f'{self.name}: {self.age}'


stu1 = Student('駱昊', 40)
print(stu1)        # 駱昊: 40
students = [stu1, Student('李元芳', 36), Student('王大錘', 25)]
print(students)    # [駱昊: 40, 李元芳: 36, 王大錘: 25]
```


### 面向對象的支柱

面向對象編程有三大支柱，就是我們之前給大家劃重點的時候圈出的三個詞：**封裝**、**繼承**和**多態**。後面兩個概念在下一節課中會詳細說明，這裡我們先說一下什麼是封裝。我自己對封裝的理解是：**隱藏一切可以隱藏的實現細節，只向外界暴露簡單的調用接口**。我們在類中定義的對象方法其實就是一種封裝，這種封裝可以讓我們在創建對象之後，只需要給對象發送一個消息就可以執行方法中的代碼，也就是說我們在只知道方法的名字和參數（方法的外部視圖），不知道方法內部實現細節（方法的內部視圖）的情況下就完成了對方法的使用。

舉一個例子，假如要控制一個機器人幫我倒杯水，如果不使用面向對象編程，不做任何的封裝，那麼就需要向這個機器人發出一系列的指令，如站起來、向左轉、向前走5步、拿起面前的水杯、向後轉、向前走10步、彎腰、放下水杯、按下出水按鈕、等待10秒、鬆開出水按鈕、拿起水杯、向右轉、向前走5步、放下水杯等，才能完成這個簡單的操作，想想都覺得麻煩。按照面向對象編程的思想，我們可以將倒水的操作封裝到機器人的一個方法中，當需要機器人幫我們倒水的時候，只需要向機器人對象發出倒水的消息就可以了，這樣做不是更好嗎？

在很多場景下，面向對象編程其實就是一個三步走的問題。第一步定義類，第二步創建對象，第三步給對象發消息。當然，有的時候我們是不需要第一步的，因為我們想用的類可能已經存在了。之前我們說過，Python內置的`list`、`set`、`dict`其實都不是函數而是類，如果要創建列表、集合、字典對象，我們就不用自定義類了。當然，有的類並不是Python標準庫中直接提供的，它可能來自於第三方的代碼，如何安裝和使用三方代碼在後續課程中會進行討論。在某些特殊的場景中，我們會用到名為“內置對象”的對象，所謂“內置對象”就是說上面三步走的第一步和第二步都不需要了，因為類已經存在而且對像已然創建過了，直接向對象發消息就可以了，這也就是我們常說的“開箱即用”。

### 經典案例

#### 案例1：定義一個類描述數字時鐘。

```Python
import time


# 定義數字時鐘類
class Clock(object):
    """數字時鐘"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法
        :param hour: 時
        :param minute: 分
        :param second: 秒
        """
        self.hour = hour
        self.min = minute
        self.sec = second

    def run(self):
        """走字"""
        self.sec += 1
        if self.sec == 60:
            self.sec = 0
            self.min += 1
            if self.min == 60:
                self.min = 0
                self.hour += 1
                if self.hour == 24:
                    self.hour = 0

    def show(self):
        """顯示時間"""
        return f'{self.hour:0>2d}:{self.min:0>2d}:{self.sec:0>2d}'


# 創建時鐘對象
clock = Clock(23, 59, 58)
while True:
    # 給時鐘對象發消息讀取時間
    print(clock.show())
    # 休眠1秒鐘
    time.sleep(1)
    # 給時鐘對象發消息使其走字
    clock.run()
```

#### 案例2：定義一個類描述平面上的點，要求提供計算到另一個點距離的方法。

```Python
class Point(object):
    """屏面上的點"""

    def __init__(self, x=0, y=0):
        """初始化方法
        :param x: 橫坐標
        :param y: 縱坐標
        """
        self.x, self.y = x, y

    def distance_to(self, other):
        """計算與另一個點的距離
        :param other: 另一個點
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5

    def __str__(self):
        return f'({self.x}, {self.y})'


p1 = Point(3, 5)
p2 = Point(6, 9)
print(p1, p2)
print(p1.distance_to(p2))
```

### 簡單的總結

面向對象編程是一種非常流行的編程範式，除此之外還有**指令式編程**、**函數式編程**等編程範式。由於現實世界是由對象構成的，而對像是可以接收消息的實體，所以**面向對象編程更符合人類正常的思維習慣**。類是抽象的，對像是具體的，有了類就能創建對象，有了對象就可以接收消息，這就是面向對象編程的基礎。定義類的過程是一個抽象的過程，找到對象公共的屬性屬於數據抽象，找到對象公共的方法屬於行為抽象。抽象的過程是一個仁者見仁智者見智的過程，對同一類對象進行抽象可能會得到不同的結果，如下圖所示。

<img src="https://gitee.com/jackfrued/mypic/raw/master/20210731182914.png" width="75%">

> **說明：** 本節課的插圖來自於 Grady Booc 等撰寫的《面向對象分析與設計》一書，該書是講解面向對象編程的經典著作，有興趣的讀者可以購買和閱讀這本書來了解更多的面向對象的相關知識。

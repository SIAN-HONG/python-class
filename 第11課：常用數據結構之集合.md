## 第11課：常用數據結構之集合

在學習了列表和元組之後，我們再來學習一種容器型的數據類型，它的名字叫集合（set）。說到集合這個詞大家一定不會陌生，在數學課本上就有這個概念。通常我們對集合的定義是“**把一定範圍的、確定的、可以區別的事物當作一個整體來看待**”，集合中的各個事物通常稱為集合的**元素**。集合應該滿足以下特性：

1. **無序性**：一個集合中，每個元素的地位都是相同的，元素之間是無序的。
2. **互異性**：一個集合中，任何兩個元素都是不相同的，即元素在集合中只能出現一次。
3. **確定性**：給定一個集合和一個任意元素，該元素要么屬這個集合，要么不屬於這個集合，二者必居其一，不允許有模棱兩可的情況出現。

Python程序中的集合跟數學上的集合是完全一致的，需要強調的是上面所說的無序性和互異性。無序性說明集合中的元素並不像列中的元素那樣一個挨著一個，可以通過索引實現隨機訪問（隨機訪問指的是給定一個有效的範圍，隨機抽取出一個數字，然後通過這個數字可以獲取到對應的元素），所以Python中的**集合肯定不能夠支持索引運算**。另外，集合的互異性決定了**集合中不能有重複元素**，這一點也是集合區別於列表的關鍵，說得更直白一些就是，Python中的集合類型會對其中的元素做去重處理。 Python中的集合一定是支持`in`和`not in`成員運算的，這樣就可以確定一個元素是否屬於集合，也就是上面所說的集合的確定性。 **集合的成員運算在性能上要優於列表的成員運算**，這是集合的底層存儲特性（哈希存儲）決定的，此處我們暫時不做討論，大家可以先記下這個結論。

### 創建集合

在Python中，創建集合可以使用`{}`字面量語法，`{}`中需要至少有一個元素，因為沒有元素的`{}`並不是空集合而是一個空字典，我們下一節課就會大家介紹字典的知識。當然，也可以使用內置函數`set`來創建一個集合，準確的說`set`並不是一個函數，而是創建集合對象的構造器，這個知識點我們很快也會講到，現在不理解跳過它就可以了。要創建空集合可以使用`set()`；也可以將其他序列轉換成集合，例如：`set('hello')`會得到一個包含了4個字符的集合（重複的`l`會被去掉）。除了這兩種方式，我們還可以使用生成式語法來創建集合，就像我們之前用生成式創建列表那樣。要知道集合中有多少個元素，還是使用內置函數`len`；使用`for`循環可以實現對集合元素的遍歷。

```Python
# 創建集合的字面量語法(重複元素不會出現在集合中)
set1 = {1, 2, 3, 3, 3, 2}
print(set1)         # {1, 2, 3}
print(len(set1))    # 3

# 創建集合的構造器語法(後面會講到什麼是構造器)
set2 = set('hello')
print(set2)         # {'h', 'l', 'o', 'e'}

# 將列表轉換成集合(可以去掉列表中的重複元素)
set3 = set([1, 2, 3, 3, 2, 1])
print(set3)         # {1, 2, 3}

# 創建集合的生成式語法(將列表生成式的[]換成{})
set4 = {num for num in range(1, 20) if num % 3 == 0 or num % 5 == 0}
print(set4)         # {3, 5, 6, 9, 10, 12, 15, 18}

# 集合元素的循環遍歷
for elem in set4:
    print(elem)
```

需要提醒大家，集合中的元素必須是`hashable`類型。所謂`hashable`類型指的是能夠計算出哈希碼的數據類型，大家可以暫時將哈希碼理解為和變量對應的唯一的ID值。通常不可變類型都是`hashable`類型，如整數、浮點、字符串、元組等，而可變類型都不是`hashable`類型，因為可變類型無法確定唯一的ID值，所以也就不能放到集合中。集合本身也是可變類型，所以集合不能夠作為集合中的元素，這一點在使用集合的時候一定要注意。

### 集合的運算

Python為集合類型提供了非常豐富的運算符，主要包括：成員運算、交集運算、並集運算、差集運算、比較運算（相等性、子集、超集）等。

#### 成員運算

可以通過成員運算`in`和`not in `檢查元素是否在集合中，代碼如下所示。

```Python
set1 = {11, 12, 13, 14, 15}
print(10 in set1)        # False 
print(15 in set1)        # True
set2 = {'Python', 'Java', 'Go', 'Swift'}
print('Ruby' in set2)    # False
print('Java' in set2)    # True
```

#### 交並差運算

Python中的集合跟數學上的集合一樣，可以進行交集、並集、差集等運算，而且可以通過運算符和方法調用兩種方式來進行操作，代碼如下所示。

```Python
set1 = {1, 2, 3, 4, 5, 6, 7}
set2 = {2, 4, 6, 8, 10}

# 交集
# 方法一: 使用 & 運算符
print(set1 & set2)                # {2, 4, 6}
# 方法二: 使用intersection方法
print(set1.intersection(set2))    # {2, 4, 6}

# 並集
# 方法一: 使用 | 運算符
print(set1 | set2)         # {1, 2, 3, 4, 5, 6, 7, 8, 10}
# 方法二: 使用union方法
print(set1.union(set2))    # {1, 2, 3, 4, 5, 6, 7, 8, 10}

# 差集
# 方法一: 使用 - 運算符
print(set1 - set2)              # {1, 3, 5, 7}
# 方法二: 使用difference方法
print(set1.difference(set2))    # {1, 3, 5, 7}

# 對稱差
# 方法一: 使用 ^ 運算符
print(set1 ^ set2)                        # {1, 3, 5, 7, 8, 10}
# 方法二: 使用symmetric_difference方法
print(set1.symmetric_difference(set2))    # {1, 3, 5, 7, 8, 10}
# 方法三: 對稱差相當於兩個集合的並集減去交集
print((set1 | set2) - (set1 & set2))      # {1, 3, 5, 7, 8, 10}
```

通過上面的代碼可以看出，對兩個集合求交集，`&`運算符和`intersection`方法的作用是完全相同的，使用運算符的方式更直觀而且代碼也比較簡短。相信大家對交集、並集、差集、對稱差這幾個概念是比較清楚的，如果沒什麼印象了可以看看下面的圖。

<img src="https://gitee.com/jackfrued/mypic/raw/master/20210819154520.png" width="90%">

集合的交集、並集、差集運算還可以跟賦值運算一起構成複合賦值運算，如下所示。

```Python
set1 = {1, 3, 5, 7}
set2 = {2, 4, 6}
# 將set1和set2求並集再賦值給set1
# 也可以通過set1.update(set2)來實現
set1 |= set2
print(set1)    # {1, 2, 3, 4, 5, 6, 7}
set3 = {3, 6, 9}
# 將set1和set3求交集再賦值給set1
# 也可以通過set1.intersection_update(set3)來實現
set1 &= set3
print(set1)    # {3, 6}
```

#### 比較運算

兩個集合可以用`==`和`!=`進行相等性判斷，如果兩個集合中的元素完全相同，那麼`==`比較的結果就是`True`，否則就是`False`。如果集合`A`的任意一個元素都是集合`B`的元素，那麼集合`A`稱為集合`B`的子集，即對於$ \forall{a} \in {A}$，均有$ {a} \in {B} $，則$ {A} \subseteq {B} $，`A`是`B`的子集，反過來也可以稱`B`是`A`的超集。如果`A`是`B`的子集且`A`不等於`B`，那麼`A`就是`B`的真子集。 Python為集合類型提供了判斷子集和超集的運算符，其實就是我們非常熟悉的`<`和`>`運算符，代碼如下所示。

```Python
set1 = {1, 3, 5}
set2 = {1, 2, 3, 4, 5}
set3 = set2
# <運算符表示真子集，<=運算符表示子集
print(set1 < set2, set1 <= set2)    # True True
print(set2 < set3, set2 <= set3)    # False True
# 通過issubset方法也能進行子集判斷
print(set1.issubset(set2))      # True

# 反過來可以用issuperset或>運算符進行超集判斷
print(set2.issuperset(set1))    # True
print(set2 > set1)              # True
```


### 集合的方法

Python中的集合是可變類型，我們可以通過集合類型的方法為集合添加或刪除元素。

```Python
# 創建一個空集合
set1 = set()

# 通過add方法添加元素
set1.add(33)
set1.add(55)
set1.update({1, 10, 100, 1000})
print(set1)    # {33, 1, 100, 55, 1000, 10}

# 通過discard方法刪除指定元素
set1.discard(100)
set1.discard(99)
print(set1)    # {1, 10, 33, 55, 1000}

# 通過remove方法刪除指定元素，建議先做成員運算再刪除
# 否則元素如果不在集合中就會引發KeyError異常
if 10 in set1:
    set1.remove(10)
print(set1)    # {33, 1, 55, 1000}

# pop方法可以從集合中隨機刪除一個元素並返回該元素
print(set1.pop())

# clear方法可以清空整個集合
set1.clear()

print(set1)    # set()
```

如果要判斷兩個集合有沒有相同的元素可以使用`isdisjoint`方法，沒有相同元素返回`True`，否則返回`False`，代碼如下所示。

```Python
set1 = {'Java', 'Python', 'Go', 'Kotlin'}
set2 = {'Kotlin', 'Swift', 'Java', 'Objective-C', 'Dart'}
set3 = {'HTML', 'CSS', 'JavaScript'}
print(set1.isdisjoint(set2))    # False
print(set1.isdisjoint(set3))    # True
```

### 不可變集合

Python中還有一種不可變類型的集合，名字叫`frozenset`。 `set`跟`frozenset`的區別就如同`list`跟`tuple`的區別，`frozenset`由於是不可變類型，能夠計算出哈希碼，因此它可以作為`set`中的元素。除了不能添加和刪除元素，`frozenset`在其他方面跟`set`基本是一樣的，下面的代碼簡單的展示了`frozenset`的用法。

```Python
set1 = frozenset({1, 3, 5, 7})
set2 = frozenset(range(1, 6))
print(set1 & set2)    # frozenset({1, 3, 5})
print(set1 | set2)    # frozenset({1, 2, 3, 4, 5, 7})
print(set1 - set2)    # frozenset({7})
print(set1 < set2)    # False
```

### 簡單的總結

Python中的集合底層使用了**哈希存儲**的方式，對於這一點我們暫時不做介紹，在後面的課程有需要的時候再為大家講解集合的底層原理，現階段大家只需要知道**集合是一種容器**，元素必須是`hashable`類型，與列表不同的地方在於集合中的元素**沒有序**、**不能用索引運算**、**不能重複**。

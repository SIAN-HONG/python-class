## 第13課：函數和模塊

在講解本節課的內容之前，我們先來研究一道數學題，請說出下面的方程有多少組正整數解。
$$
x_1 + x_2 + x_3 + x_4 = 8
$$
你可能已經想到了，這個問題其實等同於將`8`個蘋果分成四組且每組至少一個蘋果有多少種方案，因此該問題還可以進一步等價於在分隔`8`個蘋果的`7`個空隙之間插入三個隔板將蘋果分成四組有多少種方案，也就是從`7`個空隙選出`3`個空隙放入隔板的組合數，所以答案是$ C_7^3=35 $。組合數的計算公式如下所示。
$$
C_M^N = \frac {M!} {N!(M-N)!}
$$
根據我們前面學習的知識，可以用循環做累乘的方式來計算階乘，那麼通過下面的Python代碼我們就可以計算出組合數$ C_M^N $的值，代碼如下所示。

```Python
"""
輸入M和N計算C(M,N)

Version: 0.1
Author: 駱昊
"""
m = int(input('m = '))
n = int(input('n = '))
# 計算m的階乘
fm = 1
for num in range(1, m + 1):
    fm *= num
# 計算n的階乘
fn = 1
for num in range(1, n + 1):
    fn *= num
# 計算m-n的階乘
fk = 1
for num in range(1, m - n + 1):
    fk *= num
# 計算C(M,N)的值
print(fm // fn // fk)
```

### 函數的作用

不知大家是否注意到，上面的代碼中我們做了三次求階乘，雖然`m`、`n`、`m - n`的值各不相同，但是三段代碼並沒有實質性的區別，屬於重複代碼。世界級的編程大師*Martin Fowler*先生曾經說過：“**代碼有很多種壞味道，重複是最壞的一種！**”。要寫出高質量的代碼首先要解決的就是重複代碼的問題。對於上面的代碼來說，我們可以將計算階乘的功能封裝到一個稱為“函數”的代碼塊中，在需要計算階乘的地方，我們只需要“調用函數”就可以了。

### 定義函數

數學上的函數通常形如`y = f(x)`或者`z = g(x, y)`這樣的形式，在`y = f(x)`中，`f`是函數的名字，`x`是函數的自變量，`y`是函數的因變量；而在`z = g(x, y)`中，`g`是函數名，`x`和`y`是函數的自變量，`z`是函數的因變量。 Python中的函數跟這個結構是一致的，每個函數都有自己的名字、自變量和因變量。我們通常把Python中函數的自變量稱為函數的參數，而因變量稱為函數的返回值。

在Python中可以使用`def`關鍵字來定義函數，和變量一樣每個函數也應該有一個漂亮的名字，命名規則跟變量的命名規則是一致的（趕緊想一想我們之前講過的變量的命名規則）。在函數名後面的圓括號中可以放置傳遞給函數的參數，就是我們剛才說到的函數的自變量，而函數執行完成後我們會通過`return`關鍵字來返回函數的執行結果，就是我們剛才說的函數的因變量。一個函數要執行的代碼塊（要做的事情）也是通過縮進的方式來表示的，跟之前分支和循環結構的代碼塊是一樣的。大家不要忘了`def`那一行的最後面還有一個`:`，之前提醒過大家，那是在英文輸入法狀態下輸入的冒號。

我們可以通過函數對上面的代碼進行重構。 **所謂重構，是在不影響代碼執行結果的前提下對代碼的結構進行調整。 **重構之後的代碼如下所示。

```Python
"""
輸入M和N計算C(M,N)

Version: 0.1
Author: 駱昊
"""


# 定義函數：def是定義函數的關鍵字、fac是函數名，num是參數（自變量）
def fac(num):
    """求階乘"""
    result = 1
    for n in range(1, num + 1):
        result *= n
    # 返回num的階乘（因變量）
    return result


m = int(input('m = '))
n = int(input('n = '))
# 當需要計算階乘的時候不用再寫重複的代碼而是直接調用函數fac
# 調用函數的語法是在函數名後面跟上圓括號並傳入參數
print(fac(m) // fac(n) // fac(m - n))
```

> **說明**：事實上，Python標準庫的`math`模塊中有一個名為`factorial`的函數已經實現了求階乘的功能，我們可以直接使用該函數來計算階乘。 **將來我們使用的函數，要么是自定義的函數，要么是Python標準庫或者三方庫中提供的函數**。

### 函數的參數

#### 參數的默認值

如果函數中沒有`return`語句，那麼函數默認返回代表空值的`None`。另外，在定義函數時，函數也可以沒有自變量，但是函數名後面的圓括號是必須有的。 Python中還允許函數的參數擁有默認值，我們可以把之前講過的一個例子“CRAPS賭博遊戲”中搖色子獲得點數的功能封裝成函數，代碼如下所示。

```Python
"""
參數的默認值

Version: 0.1
Author: 駱昊
"""
from random import randint


# 定義搖色子的函數，n表示色子的個數，默認值為2
def roll_dice(n=2):
    """搖色子返回總的點數"""
    total = 0
    for _ in range(n):
        total += randint(1, 6)
    return total


# 如果沒有指定參數，那麼n使用默認值2，表示搖兩顆色子
print(roll_dice())
# 傳入參數3，變量n被賦值為3，表示搖三顆色子獲得點數
print(roll_dice(3))
```

我們再來看一個更為簡單的例子。

```Python
def add(a=0, b=0, c=0):
    """三個數相加求和"""
    return a + b + c


# 調用add函數，沒有傳入參數，那麼a、b、c都使用默認值0
print(add())         # 0
# 調用add函數，傳入一個參數，那麼該參數賦值給變量a, 變量b和c使用默認值0
print(add(1))        # 1
# 調用add函數，傳入兩個參數，1和2分別賦值給變量a和b，變量c使用默認值0
print(add(1, 2))     # 3
# 調用add函數，傳入三個參數，分別賦值給a、b、c三個變量
print(add(1, 2, 3))  # 6
# 傳遞參數時可以不按照設定的順序進行傳遞，但是要用“參數名=參數值”的形式
print(add(c=50, a=100, b=200))    # 350
```

> **注意**：帶默認值的參數必須放在不帶默認值的參數之後，否則將產生`SyntaxError`錯誤，錯誤消息是：`non-default argument follows default argument`，翻譯成中文的意思是“沒有默認值的參數放在了帶默認值的參數後面”。

#### 可變參數

接下來，我們還可以實現一個對任意多個數求和的`add`函數，因為Python語言中的函數可以通過星號表達式語法來支持可變參數。所謂可變參數指的是在調用函數時，可以向函數傳入`0`個或任意多個參數。將來我們以團隊協作的方式開發商業項目時，很有可能要設計函數給其他人使用，但有的時候我們並不知道函數的調用者會向該函數傳入多少個參數，這個時候可變參數就可以派上用場。下面的代碼演示了用可變參數實現對任意多個數求和的`add`函數。

```Python
"""
可變參數

Version: 0.1
Author: 駱昊
"""


# 用星號表達式來表示args可以接收0個或任意多個參數
def add(*args):
    total = 0
    # 可變參數可以放在for循環中取出每個參數的值
    for val in args:
        if type(val) in (int, float):
            total += val
    return total


# 在調用add函數時可以傳入0個或任意多個參數
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(1, 3, 5, 7, 9))
```

### 用模塊管理函數

不管用什麼樣的編程語言來寫代碼，給變量、函數起名字都是一個讓人頭疼的問題，因為我們會遇到**命名衝突**這種尷尬的情況。最簡單的場景就是在同一個`.py`文件中定義了兩個同名的函數，如下所示。

```Python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')

    
foo()    # 大家猜猜調用foo函數會輸出什麼
```

當然上面的這種情況我們很容易就能避免，但是如果項目是團隊協作多人開發的時候，團隊中可能有多個程序員都定義了名為`foo`的函數，這種情況下怎麼解決命名衝突呢？答案其實很簡單，Python中每個文件就代表了一個模塊（module），我們在不同的模塊中可以有同名的函數，在使用函數的時候我們通過`import`關鍵字導入指定的模塊再使用**完全限定名**的調用方式就可以區分到底要使用的是哪個模塊中的`foo`函數，代碼如下所示。

`module1.py`

```Python
def foo():
    print('hello, world!')
```

`module2.py`

```Python
def foo():
    print('goodbye, world!')
```

`test.py`

```Python
import module1
import module2

# 用“模塊名.函數名”的方式（完全限定名）調用函數，
module1.foo()    # hello, world!
module2.foo()    # goodbye, world!
```

在導入模塊時，還可以使用`as`關鍵字對模塊進行別名，這樣我們可以使用更為簡短的完全限定名。

`test.py`

```Python
import module1 as m1
import module2 as m2

m1.foo()    # hello, world!
m2.foo()    # goodbye, world!
```

上面的代碼我們導入了定義函數的模塊，我們也可以使用`from...import...`語法從模塊中直接導入需要使用的函數，代碼如下所示。

`test.py`

```Python
from module1 import foo

foo()    # hello, world!

from module2 import foo

foo()    # goodbye, world!
```

但是，如果我們如果從兩個不同的模塊中導入了同名的函數，後導入的函數會覆蓋掉先前的導入，就像下面的代碼中，調用`foo`會輸出`hello, world!`，因為我們先導入了`module2`的`foo`，後導入了`module1`的`foo` 。如果兩個`from...import...`反過來寫，就是另外一番光景了。

`test.py`

```Python
from module2 import foo
from module1 import
foo

foo()    # hello, world!
```

如果想在上面的代碼中同時使用來自兩個模塊中的`foo`函數也是有辦法的，大家可能已經猜到了，還是用`as`關鍵字對導入的函數進行別名，代碼如下所示。

`test.py`

```Python
from module1 import foo as f1
from module2 import foo as f2

f1()    # hello, world!
f2()    # goodbye, world!
```

### 標準庫中的模塊和函數

Python標準庫中提供了大量的模塊和函數來簡化我們的開發工作，我們之前用過的`random`模塊就為我們提供了生成隨機數和進行隨機抽樣的函數；而`time`模塊則提供了和時間操作相關的函數；上面求階乘的函數在Python標準庫中的`math`模塊中已經有了，實際開發中並不需要我們自己編寫，而`math`模塊中還包括了計算正弦、餘弦、指數、對數等一系列的數學函數。隨著我們進一步的學習Python編程知識，我們還會用到更多的模塊和函數。

Python標準庫中還有一類函數是不需要`import`就能夠直接使用的，我們將其稱之為內置函數，這些內置函數都是很有用也是最常用的，下面的表格列出了一部分的內置函數。

| 函數    | 說明                                                         |
| ------- | ------------------------------------------------------------ |
| `abs`   | 返回一個數的絕對值，例如：`abs(-1.3)`會返回`1.3`。 |
| `bin`   | 把一個整數轉換成以`'0b'`開頭的二進製字符串，例如：`bin(123)`會返回`'0b1111011'`。 |
| `chr`   | 將Unicode編碼轉換成對應的字符，例如：`chr(8364)`會返回`'€'`。 |
| `hex`   | 將一個整數轉換成以`'0x'`開頭的十六進製字符串，例如：`hex(123)`會返回`'0x7b'`。 |
| `input` | 從輸入中讀取一行，返回讀到的字符串。 |
| `len`   | 獲取字符串、列表等的長度。 |
| `max`   | 返回多個參數或一個可迭代對像中的最大值，例如：`max(12, 95, 37)`會返回`95`。 |
| `min`   | 返回多個參數或一個可迭代對像中的最小值，例如：`min(12, 95, 37)`會返回`12`。 |
| `oct`   | 把一個整數轉換成以`'0o'`開頭的八進製字符串，例如：`oct(123)`會返回`'0o173'`。 |
| `open`  | 打開一個文件並返回文件對象。 |
| `ord`   | 將字符轉換成對應的Unicode編碼，例如：`ord('€')`會返回`8364`。 |
| `pow`   | 求冪運算，例如：`pow(2, 3)`會返回`8`；`pow(2, 0.5)`會返回`1.4142135623730951`。 |
| `print` | 打印輸出。 |
| `range` | 構造一個範圍序列，例如：`range(100)`會產生`0`到`99`的整數序列。 |
| `round` | 按照指定的精度對數值進行四捨五入，例如：`round(1.23456, 4)`會返回`1.2346`。 |
| `sum`   | 對一個序列中的項從左到右進行求和運算，例如：`sum(range(1, 101))`會返回`5050`。 |
| `type`  | 返回對象的類型，例如：`type(10)`會返回`int`；而` type('hello')`會返回`str`。 |

###  簡單的總結

**函數是對功能相對獨立且會重複使用的代碼的封裝**。學會使用定義和使用函數，就能夠寫出更為優質的代碼。當然，Python語言的標準庫中已經為我們提供了大量的模塊和常用的函數，用好這些模塊和函數就能夠用更少的代碼做更多的事情；如果這些模塊和函數不能滿足我們的要求，我們就需要自定義函數，然後用模塊的概念來管理這些自定義函數。
